//--------------------第二个星期 package:  oo ------------------------

// ##################### day01: ######################
笔记:
1.什么是类？什么是对象？
  1)现实世界是由很多很多的对象组成的
    基于对象抽出了类
  2)对象:真实存在的单个的个体
    类:类型/类别，代表一类个体
  3)类中可以包含:
    3.1)所有对象所共有的属性/特征---------成员变量
	3.2)所有对象所共有的行为--------------方法
  4)一个类可以创建多个对象
    同一类型的多个对象，结构相同，数据不同
  5)类是对象的模板，对象是类的具体的实例
2.如何创建类？如何创建对象？如何访问成员？
3.引用类型之间画等号:
  1)指向同一个对象
  2)对其中一个引用的修改会影响另一个引用
    eg:房子钥匙
  基本类型之间画等号:
  1)赋值
  2)对其中一个变量的修改不会影响另一个变量
    eg:身份证复印件
4.null:空，没有指向任何对象
       若引用的值为null，则该引用不能再进行任何操作了
	   若操作则NullPointerException空指针异常
	   
// ##################### day02: ######################
笔记:
0.方法的签名:方法名+参数列表
1.方法的重载(Overload):
  1)发生在同一个类中，方法名称相同，参数列表不同
  2)编译器会自动根据方法的签名来绑定调用不同的方法
2.构造方法:
  1)给成员变量赋初值
  2)与类同名，没有返回值类型
  3)在创建对象时被自动调用
  4)若自己不写构造方法，则编译器默认提供一个无参构造方法
    若自己写了构造方法，则编译器不再默认提供
  5)构造方法可以重载
3.this:指代当前对象，哪个对象调用方法指的就是哪个对象
       只能用在方法中，方法中访问成员变量之前默认有个this.
  this的用法:
    1)this.成员变量名-------------访问成员变量
	2)this.方法名()---------------调用方法
	3)this()----------------------调用构造方法
4.引用类型数组:

// ##################### day03: ######################
笔记:
1.内存管理:由JVM管理-----------了解
  1)堆:
    1.1)用于存储所有new出来的对象(包括成员变量)
	1.2)垃圾:没有任何引用所指向的对象
	    垃圾回收器(GC)不定时到内存中清扫垃圾，
		并不一定一发现垃圾就立刻回收，
		回收过程是透明的(看不到的)
		通过调用System.gc()可以建议虚拟机尽快调度GC来回收
	1.3)内存泄漏:不再使用的内存没有被及时的回收
	    建议:不再使用的对象，及时将引用设置为null
	1.4)成员变量的生命周期:
	      创建对象时存储在堆中，对象被回收时一并被回收
  2)栈:
    2.1)用于存储正在调用的方法中的所有局部变量(包括参数)
	2.2)JVM会为每一个正在调用的方法分配一块对应的栈帧，
	    栈帧中存储方法中的局部变量(包括参数)，
		方法调用结束时，栈帧被清除，局部变量一并被清除
	2.3)局部变量的生命周期:
	      调用方法时存在栈中，方法结束时与栈帧一并被清除
  3)方法区:
    3.1)用于存储.class字节码文件(包括方法)
	3.2)方法只有一份，通过this来区分具体的对象
2.继承:
  1)作用:实现代码的复用
  2)通过extends来实现继承
  3)父类:所有子类所共有的属性和行为
    子类:子类所特有的属性和行为
  4)子类继承父类之后，子类将具有:子类的+父类的
  5)一个父类可以有多个子类
    一个子类只能有一个父类--------单一继承
  6)继承具有传递性
  7)java规定:构造子类之前必须先构造父类
    子类构造中若自己不调用父类的构造，则默认super()调用父类的无参构造
	若自己调用了父类的构造，则不再默认提供
	super()调用父类构造，必须位于子类构造的第1句
3.super:指代当前对象的父类对象
  super的用法:
    1)super.成员变量名------------访问父类的成员变量
	2)super.方法名()--------------调用父类的方法
	3)super()---------------------调用父类的构造方法
4.向上造型:
  1)父类型的引用指向子类的对象
  2)能点出来什么，看引用的类型

// ##################### day04: ######################
笔记:
1.方法的重写(Override):重新写、覆盖
  1)发生在父子类中，方法名称相同，参数列表相同，方法体不同
  2)重写方法被调用时，看对象的类型
2.重写与重载的区别:--------------常见面试题
  1)重写(Override):
    1.1)发生在父子类中，方法名称相同，参数列表相同，方法体不同
	1.2)遵循"运行期"绑定，根据对象的类型来调用方法
  2)重载(Overload):
    2.1)发生在一个类中，方法名称相同，参数列表不同，方法体不同
	2.2)遵循"编译期"绑定，根据参数(引用)的类型来绑定方法
3.package:
  1)作用:避免类的命名冲突
  2)包名可以有层次结构，类的全称: 包名.类名
  3)同包中的类不能同名，但是不同包中的类是可以同名的
  4)建议:包名所有字母都小写
  import:
  1)同包中的类可以直接访问
    不同包的中类是不能直接访问的，想访问有两种方式:
	1.1)先import再使用类---------建议
	1.2)类的全称-----------------太繁琐，不建议
4.访问控制修饰符:
  1)public:公共的，任何类
  2)private:私有的，本类
  3)protected:受保护的，本类、子类、同包类
  4)默认的:什么也不写，本类、同包类
  类的访问修饰可以是public和默认的
  类中成员的访问修饰如上4种都可以
5.static:静态的
  1)静态变量:
    1.1)由static修饰
	1.2)属于类，存储在方法区中，只有一份
	1.3)常常通过类名点来访问
	1.4)何时用:所有对象所共享的数据(图片、音频、视频等)
  2)静态方法:
    2.1)由static修饰
	2.2)属于类的，存储在方法区中，只有一份
	2.3)常常通过类名点来访问
	2.4)静态方法没有隐式的this传递，
	    静态方法中不能直接访问实例成员
	2.5)何时用:方法的操作仅与参数相关而与对象无关
  3)静态块:
    3.1)由static修饰
	3.2)属于类的，在类被加载期间自动执行的，
	    因为类只被加载一次，所以静态块也只执行一次
	3.3)何时用:加载/初始化静态资源(图片、音频、视频等)
6.final:最终的、不可改变的
  1)修饰变量:变量不能被改变
  2)修饰方法:方法不能被重写
  3)修饰类:类不能被继承
7.static final常量: 自学

// ##################### day05: ######################
笔记:
1.static final常量:
  1)必须声明同时初始化
  2)通过类名点来访问，不能改变
  3)建议:常量名所有字母都大写，多个单词用_分隔
  4)编译器在编译时将常量直接替换为具体的值，效率高
2.抽象方法:
  1)由abstract修饰
  2)只有方法的定义，没有具体的实现(连{}都没有)
3.抽象类:
  1)由abstract修饰
  2)包含抽象方法的类必须是抽象类
    不包含抽象方法的类也可以声明为抽象类-------我乐意
  3)抽象类不能被实例化
  4)抽象类是需要被继承的，子类:
    4.1)重写所有抽象方法---------常常这样做
	4.2)也声明为抽象类-----------一般不这样做
  5)抽象类的意义:
    5.1)封装所有子类所共有的属性和行为-------代码复用
	5.2)为所有子类提供了统一的类型-----------向上造型
	5.3)可以包含抽象方法，为所有子类提供了统一的入口
	    子类的具体实现是不同的，但方法的定义是一致的
4.接口:
  1)是一个标准、规范----------制定方
    遵守了这个标准，就能干某件事-----------API才能理解
  2)接口是一种数据类型(引用类型)
  3)由interface定义
    只能包含常量和抽象方法
  4)接口不能被实例化
  5)接口是需要被实现的，实现类:
      必须重写接口中的所有抽象方法
  6)一个类可以实现多个接口，用逗号分隔
    若又继承又实现时，应先继承后实现
  7)接口可以继承接口

// ##################### day06: ######################
正课:
1.多态:
  1)意义:
    1.1)同一类型的引用，在指向不同的对象时，有不同的实现
	    ------行为的多态:cut(),run(),teach(),area()
	1.2)同一个对象，被造型为不同的类型时，有不同的功能
	    ------对象的多态:我、水
  2)向上造型:
    2.1)父类型的引用指向子类的对象
	2.2)能造型成为的类型有: 父类、所实现的接口
	2.3)能点出来什么，看引用的类型
  3)强制类型转换，成功的条件有两种:
    3.1)引用所指向的对象，就是该类型
	3.2)引用所指向的对象，实现了该接口
  4)强转时若不符合如上两个条件，则发生ClassCastException类型转换异常
    建议:强转之前先通过instanceof来判断引用所指向的对象是否是该类型
2.成员内部类: 应用率不高
  1)类中套类，外面的称为外部类Outer，里面的称为内部类Inner
  2)内部类通常只服务于外部类，对外不具备可见性
  3)内部类对象通常是在外部类中创建的
  4)内部类中可以直接访问外部类的成员(包括私有的)
    内部类中有一个隐式的引用指向了创建它的外部类对象
	  eg: 外部类名.this
3.匿名内部类:
  1)若想创建一个类(子类)的对象，并且对象只被创建一次，
    此时该类可以不必命名，称为匿名内部类
  2)匿名内部类中若想访问外部的变量，该变量必须是final的



// ######################## 总结: ##############################
面向对象三大特征:
1.封装:
  1)类:封装的是对象的属性和行为
  2)方法:封装的是具体的业务逻辑功能实现
  3)访问控制修饰符:封装的是访问的权限
2.继承:
  1)代码的复用
  2)父类/基类:所有子类所共有的属性和行为
    子类/派生类:子类所特有的属性和行为
  3)子类继承父类之后，子类具有:父类的+子类的
  4)传递性、单一继承、多接口实现
3.多态:
  1)意义:行为的多态、对象的多态
  2)向上造型、强制类型转换、instanceof判断
  3)多态的表现形式: 
    3.1)重写(依据对象的不同来实现多态)
    3.2)重载(依据参数的不同来实现多态)


面向对象课程安排:
第一天:
  1)什么是类？什么是对象？
  2)如何创建类？如何创建对象？如何访问类中成员？
  3)引用类型画等号
  4)null和NullPointerException
第二天:
  1)方法的重载:
  2)构造方法:
  3)this:
  4)引用类型数组:
第三天:
  1)内存管理:
  2)继承:
  3)super:
  4)向上造型:
第四天:
  1)方法的重写、重写与重载的区别
  2)package和import
  3)访问控制修饰符:
  4)static:
  5)final:
  6)static final常量:
第五天:
  1)抽象方法:
  2)抽象类:
  3)接口:
第六天:
  1)多态:意义、向上造型、强转、instanceof
  2)内部类:成员内部类、匿名内部类

设计规则:
1)将所有子类所共有的属性和行为，抽象到父类中
2)所有子类行为都一样，设计为普通方法
  所有子类行为都不一样，设计为抽象方法
3)将部分子类所共有的行为，抽象到接口中
  符合既是也是原则时，使用接口
  接口是对继承的单根性的扩展-----实现多继承



